package e2e
//go:build integration
// +build integration

package e2e

import (
	"strings"
	"testing"

	"github.com/dynatrace-oss/dtctl/pkg/resources/appengine"
	"github.com/dynatrace-oss/dtctl/test/integration"






























































































































































































































































}	})		}			t.Logf("  Fields: %+v", schema.Fields)		if len(schema.Fields) > 0 {		t.Logf("✓ Discovered schema with %d fields", len(schema.Fields))		}			t.Log("Warning: Schema has no fields and no error message")		if len(schema.Fields) == 0 && schema.ErrorMessage == "" {		// Schema should have either fields or an error message		}			t.Errorf("App ID mismatch: got %q, want %q", schema.AppID, testFunction.AppID)		if schema.AppID != testFunction.AppID {		}			t.Errorf("Function name mismatch: got %q, want %q", schema.FunctionName, testFunction.FunctionName)		if schema.FunctionName != testFunction.FunctionName {		}			t.Fatal("Expected schema, got nil")		if schema == nil {		}			t.Fatalf("DiscoverSchema() failed: %v", err)		if err != nil {		schema, err := functionHandler.DiscoverSchema(testFunction.AppID, testFunction.FunctionName)		t.Logf("Testing schema discovery with: %s", testFunction.FullName)		}			t.Skip("No suitable function found for schema discovery test")		if testFunction == nil {		}			}				break				testFunction = &fn			if strings.Contains(fn.FunctionName, "dql") || strings.Contains(fn.FunctionName, "query") {			// Look for a function that's likely to have a discoverable schema		for _, fn := range functions {		var testFunction *appengine.AppFunction		}			t.Fatalf("ListFunctions() failed: %v", err)		if err != nil {		functions, err := appHandler.ListFunctions("")		// Try to find dynatrace.automations/execute-dql-query which is commonly available	t.Run("discover schema for known function", func(t *testing.T) {	functionHandler := appengine.NewFunctionHandler(env.Client)	appHandler := appengine.NewHandler(env.Client)	defer env.Cleanup.Cleanup(t)	env := integration.SetupIntegration(t)func TestFunctionSchemaDiscovery(t *testing.T) {}	})		t.Logf("✓ Correctly rejected nonexistent app")		}			t.Errorf("Expected 'not found' error, got: %v", err)		if !strings.Contains(err.Error(), "not found") {		}			t.Error("Expected error for nonexistent app, got nil")		if err == nil {		_, err := handler.GetApp("nonexistent.app.that.does.not.exist")	t.Run("get nonexistent app", func(t *testing.T) {	})		t.Logf("✓ Successfully retrieved app: %s (%s)", app.Name, app.ID)		}			t.Errorf("App ID mismatch: got %q, want %q", app.ID, testAppID)		if app.ID != testAppID {		}			t.Fatalf("GetApp() failed: %v", err)		if err != nil {		app, err := handler.GetApp(testAppID)		t.Logf("Testing with app: %s", testAppID)		testAppID := apps.Apps[0].ID		}			t.Skip("No apps available for get test")		if len(apps.Apps) == 0 {		}			t.Fatalf("ListApps() failed: %v", err)		if err != nil {		apps, err := handler.ListApps()		// First list apps to get a valid app ID	t.Run("get specific app", func(t *testing.T) {	})		}			}				t.Errorf("App missing Name: %+v", app)			if app.Name == "" {			}				t.Errorf("App missing ID: %+v", app)			if app.ID == "" {		for _, app := range apps.Apps {		// Verify app structure		t.Logf("✓ Found %d apps", len(apps.Apps))		}			t.Skip("No apps found - skipping test")		if len(apps.Apps) == 0 {		}			t.Fatalf("ListApps() failed: %v", err)		if err != nil {		apps, err := handler.ListApps()	t.Run("list all apps", func(t *testing.T) {	handler := appengine.NewHandler(env.Client)	defer env.Cleanup.Cleanup(t)	env := integration.SetupIntegration(t)func TestAppsGet(t *testing.T) {}	})		t.Logf("✓ Correctly rejected invalid function name format")		}			t.Errorf("Expected 'invalid function name format' error, got: %v", err)		if !strings.Contains(err.Error(), "invalid function name format") {		}			t.Error("Expected error for invalid format, got nil")		if err == nil {		_, err := handler.GetFunction("invalid-format-without-slash")	t.Run("invalid function name format", func(t *testing.T) {	})		t.Logf("✓ Correctly rejected nonexistent function")		}			t.Errorf("Expected 'not found' error, got: %v", err)		if !strings.Contains(err.Error(), "not found") {		}			t.Error("Expected error for nonexistent function, got nil")		if err == nil {		_, err := handler.GetFunction("nonexistent.app/fake-function")	t.Run("get nonexistent function", func(t *testing.T) {	})		t.Logf("✓ Successfully retrieved function: %s", fn.FullName)		}			t.Errorf("FullName mismatch: got %q, want %q", fn.FullName, testFunction.FullName)		if fn.FullName != testFunction.FullName {		}			t.Errorf("FunctionName mismatch: got %q, want %q", fn.FunctionName, testFunction.FunctionName)		if fn.FunctionName != testFunction.FunctionName {		}			t.Errorf("AppID mismatch: got %q, want %q", fn.AppID, testFunction.AppID)		if fn.AppID != testFunction.AppID {		// Verify returned data		}			t.Fatalf("GetFunction() failed: %v", err)		if err != nil {		fn, err := handler.GetFunction(testFunction.FullName)		// Get the specific function		t.Logf("Testing with function: %s", testFunction.FullName)		testFunction := functions[0]		}			t.Skip("No functions available for get test")		if len(functions) == 0 {		}			t.Fatalf("ListFunctions() failed: %v", err)		if err != nil {		functions, err := handler.ListFunctions("")		// First list functions to get a valid function name	t.Run("get specific function", func(t *testing.T) {	})		t.Logf("✓ Filtered to %d functions for app %s", len(filteredFunctions), testAppID)		}			}				t.Errorf("Expected app ID %q, got %q", testAppID, fn.AppID)			if fn.AppID != testAppID {		for _, fn := range filteredFunctions {		// All returned functions should belong to the filtered app		}			t.Fatalf("ListFunctions() with filter failed: %v", err)		if err != nil {		filteredFunctions, err := handler.ListFunctions(testAppID)		testAppID := allFunctions[0].AppID		}			t.Skip("No functions available for filtering test")		if len(allFunctions) == 0 {		}			t.Fatalf("ListFunctions() failed: %v", err)		if err != nil {		allFunctions, err := handler.ListFunctions("")		// First get all functions to find a valid app ID	t.Run("filter functions by app", func(t *testing.T) {	})		}			}				t.Errorf("FullName mismatch: got %q, want %q", fn.FullName, expectedFullName)			if fn.FullName != expectedFullName {			expectedFullName := fn.AppID + "/" + fn.FunctionName			// Verify full name format			}				t.Errorf("Function missing FullName: %+v", fn)			if fn.FullName == "" {			}				t.Errorf("Function missing FunctionName: %+v", fn)			if fn.FunctionName == "" {			}				t.Errorf("Function missing AppID: %+v", fn)			if fn.AppID == "" {		for _, fn := range functions {		// Verify function structure		t.Logf("✓ Found %d functions", len(functions))		}			t.Skip("No functions found - skipping test")		if len(functions) == 0 {		// Should have at least the built-in automations functions		}			t.Fatalf("ListFunctions() failed: %v", err)		if err != nil {		functions, err := handler.ListFunctions("")	t.Run("list all functions", func(t *testing.T) {	handler := appengine.NewHandler(env.Client)	defer env.Cleanup.Cleanup(t)	env := integration.SetupIntegration(t)func TestFunctionsGet(t *testing.T) {)